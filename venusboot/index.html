<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="base-url" content="http://venusplus.cn/">
    <link type="image/png" href="/images/head.png" rel="shortcut icon" />
    <base href="http://venusplus.cn/">
    <link rel="stylesheet" href="css/main.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_18677_3gesaak2gctyb9.css">
    <link href="css/default.css" rel="stylesheet">
    <link href="css/vendor/antd.min.css" rel="stylesheet">
    <link href="css/vendor/swiper.min.css" rel="stylesheet">
    <title>Venus中间件-Venus Boot 介绍</title>
    <script src="js/vendor/jquery-3.2.1.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="js/common.min.js" type="text/javascript" charset="utf-8"></script>
    <link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet">

    <style type="text/css">

.gitter-open-chat-button {
      right: 20px;
    padding: 10px;
    background-color: #00c1de;
}
@media (max-width: 600px) {
    .gitter-open-chat-button,
    .gitter-chat-embed {
        display: none;
    }
}
#sofa-product .product-function .product-function-wrapper .product-function-card .title {
    padding-bottom: 16px;
    color: #00c1de;
    font-size: 24px;
}

.ant-btn-primary {
    color: #fff;
    background-color: #00c1de;
    border-color: #00c1de;
}

    </style>

  </head>
  <body data-url="/venusboot/" class="theme">
    
<div class="header">
  <div>
    <div class="header-wrapper">
      <div class="header-logo">
        <a href=/>
          <img src="/images/logo.png" alt="">
        </a>
      </div>
      <ul class="sofa-menu ant-menu ant-menu-horizontal ant-menu-light ant-menu-root" role="menu">
        
          <li class="ant-menu-item sofa-menu-item  ">
              
              <div class="sofa-menu-item-text">
                
                  <a href="/">首页</a>
                
                
                
              </div>
          </li>
        
          <li class="ant-menu-item sofa-menu-item  ">
              
              <div class="product-menu">
                <div class="product-menu-wrapper">
                  
                    <div class="product-menu-col">
                      <div class="product-menu-title">快速开发框架</div>
                      
                        <a href=/product/venus class="product-menu-title-link">Venus</a>
                      
                        <a href=/product/venusboot class="product-menu-title-link">Venus Boot</a>
                      
                    </div>
                  
                    <div class="product-menu-col">
                      <div class="product-menu-title">微服务框架</div>
                      
                        <a href=/product/venus-cloud class="product-menu-title-link">Venus Cloud</a>
                      
                    </div>
                  
                    <div class="product-menu-col">
                      <div class="product-menu-title">经典中间件</div>
                      
                        <a href=/product/talos class="product-menu-title-link">Talos网关</a>
                      
                        <a href=/product/minos class="product-menu-title-link">Minos配置中心</a>
                      
                    </div>
                  
                    <div class="product-menu-col">
                      <div class="product-menu-title">数据中间件</div>
                      
                        <a href=/product/venus-dts class="product-menu-title-link">Venus DTS</a>
                      
                    </div>
                  
                    <div class="product-menu-col">
                      <div class="product-menu-title">工具和公共类库</div>
                      
                        <a href=/product/venus-codegen class="product-menu-title-link">Venus CodeGen</a>
                      
                    </div>
                  
                </div>
              </div>
              
              <div class="sofa-menu-item-text">
                
                  <a href="javascript:;">产品</a>
                
                
                
              </div>
          </li>
        
          <li class="ant-menu-item sofa-menu-item  ">
              
              <div class="sofa-menu-item-text">
                
                  <a href="/#">文档</a>
                
                
                
              </div>
          </li>
        
          <li class="ant-menu-item sofa-menu-item  ">
              
              <div class="sofa-menu-item-text">
                
                  <a href="/#">控制台</a>
                
                
                
              </div>
          </li>
        
          <li class="ant-menu-item sofa-menu-item  ">
              
              <div class="sofa-menu-item-text">
                
                  <a href="/#">关于我们</a>
                
                
                
              </div>
          </li>
        

      </ul>
      <div class="sofa-menu-right pull-right">
       
        <div class="search">
          <span class="ant-input-group-wrapper" style="width: 262px;">
            <span class="ant-input-wrapper ant-input-group">
              
              <span class="ant-input-search ant-input-affix-wrapper">
                <form class="search-form" action=/search method="get">
                    <input type="text" name="q" placeholder="请输入搜索内容" value="" class="ant-input" autocomplete="off" />
                    <input type="hidden" name="title" value="新人上手">
                </form>
                <span class="ant-input-suffix">
                  <i class="anticon anticon-search ant-input-search-icon"></i>
                </span>
              </span>
            </span>
          </span>
        </div>

       
        
      </div>
    </div>
  </div>
</div>

    <div class="main">
      
  
  
    <div class="pg-artical " id="pg-artical">
      <div class="wrap">
        
<div class="nav-section">
  <div class="navbar">
    <span class="larkicon larkicon-toc"></span>
  </div>
  <nav class="nav-container">
    <ul class="catalog">
      
    </ul>
  </nav>
</div>

        <div class="main-container">
          <div id="page-toc"></div>
          <div class="artical-section larksite">
    <div class="doc-article">
      <article class="doc-article-inner">
        <div class="typo">
          <h1 class="typo-title" itemprop="title">
          Venus Boot 介绍
          </h1>
          <p class="meta">更新时间: <span>2017-4-27</span></p>
          <div class="typo-content">
            

<p><strong>摘要</strong>:  本文主要从网关的需求，以及Spring Cloud Zuul的线程模型和源码瓶颈分析结合，目前最近一段时间自研网关中间件纳管Spring Cloud的经验汇总整理。</p>

<h2 id="一-自研网关纳管spring-cloud的原因">一.自研网关纳管Spring Cloud的原因</h2>

<h3 id="1-1-为什么要自研网关">1.1 为什么要自研网关</h3>

<p>1.网关配置实时生效，配置灰度，回滚等
2.网关的性能，特别是防刷，限流，WAF等
3.动态Filter ，目前Zuul可以做到动态Filter，Filter配置下发，实时动态Filter
4.对网关的监控，告警，流量调拨，网关集群。
5.流程审计，增加Dsboard便捷的操作。</p>

<h3 id="1-2-回顾web容器线程模型">1.2 回顾Web容器线程模型</h3>

<p>Servlet只是基于Java技术的web组件，该组件由容器托管，用于生成动态内容。Servlet容器是web Server或application server 的一部分，供基于Request/Response发送模型的网络服务，解码基于MIME的请求，并格式化基于MIME的响应。Servlet容器包含并管理Servlet生命周期。典型的Servlet容器有Tomcat、Jetty。</p>

<p><img src="/images/mw/gw/janus-03.png" width="650px" height="450px"></p>

<p>如上图所示，Tomcat基于NIO的多线程模型，如下图所示，其基于典型的Acceptor/Reactor线程模型，在Tomcat的线程模型中，Worker线程用来处理Request。当容器收到一个Request后，调度线程从Worker线程池中选出一个Worker线程，将请求传递给该线程，然后由该线程来执行Servlet的service()方法。且该worker线程只能同时处理一个Request请求，如果过程中发生了阻塞，那么该线程就会被阻塞，而不能去处理其他任务。 Servlet默认情况下一个单例多线程。</p>

<p><img src="/images/mw/gw/janus-04.png" width="650px" height="450px"></p>

<p>回到zuul，zuul逻辑的入口是<code>ZuulServlet</code>.service(ServletRequest servletRequest, ServletResponse servletResponse)，ZuulServlet本质就是一个Servlet。</p>

<p><code>RequestContext</code>提供了执行filter Pipeline所需要的Context，因为Servlet是<code>单例多线程</code>，这就要求RequestContext即要线程安全又要Request安全。context使用ThreadLocal保存，这样每个worker线程都有一个与其绑定的RequestContext，因为worker仅能同时处理一个Request，<code>这就保证了Request Context 即是线程安全的，又是Request安全的</code>。所谓Request 安全，即该Request的Context不会与其他同时处理Request冲突。 RequestContext继承了ConcurrentHashMap。</p>

<p>三个核心的方法preRoute(),route(), postRoute()，zuul对request处理逻辑都在这三个方法里，<code>ZuulServlet交给ZuulRunner去执行</code>。由于<code>ZuulServlet是单例</code>，因此<code>ZuulRunner也仅有一个实例</code>。</p>

<blockquote>
<p>因此综上所述，Spring Cloud Zuul的Qps在<code>1000-2000</code>Qps之间是有原因的，网关作为如此重要的组件，基于如上所述的需求，觉得自研网关中间件纳管Spring Cloud很有必要。</p>
</blockquote>

<h2 id="二-自研网关纳管spring-cloud">二.自研网关纳管Spring Cloud</h2>

<h3 id="2-1-网关整合spring-cloud服务治理体系">2.1 网关整合Spring Cloud服务治理体系</h3>

<h4 id="2-1-1-整合服务治理体系思路">2.1.1 整合服务治理体系思路</h4>

<ul>
<li>如果服务注册中心使用的是Eureka，可以不引入Spring Cloud Eureka相关的依赖，直接通过定时任务发起Eureka REST请求，网关自身维护一个缓存列表，自己写LB，找到服务列表转发。</li>
</ul>

<blockquote>
<p>优点：不需要引入Spring Cloud，对网关Server进行瘦身，洁癖讨厌各种引入无用的jar；
缺点: 注册中心使用Eureka，可以通过Eureka REST接口获取服务注册列表，但是换成ZK，Consul，或者Etcd，直接歇菜。</p>
</blockquote>

<hr />

<ul>
<li>通过集成Spring Cloud Common中高度抽象的DiscoveryClient。
&gt; 优点: 通过高度抽象的DiscoveryClient，无需关心实现细节和定时任务去刷新注册列表。
&gt; 缺点：换注册中心，需要相应的更换对应配置和依赖，一堆有些无关紧要的jar，需要自己对其瘦身。</li>
</ul>

<h4 id="2-1-2-网关整合spring-cloud-eureka">2.1.2 网关整合Spring Cloud Eureka</h4>

<p>1.引入Spring Cloud Eureka Starter，排除不用的依赖，还需要努力瘦身ing。</p>

<pre><code class="language-xml">  &lt;dependency&gt;
	   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
	  &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;
	   &lt;version&gt;1.3.1.RELEASE&lt;/version&gt;
		 &lt;exclusions&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
					&lt;artifactId&gt;spring-cloud-netflix-core&lt;/artifactId&gt;
				&lt;/exclusion&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;com.netflix.ribbon&lt;/groupId&gt;
					&lt;artifactId&gt;ribbon-eureka&lt;/artifactId&gt;
				&lt;/exclusion&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
					&lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;
				&lt;/exclusion&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
					&lt;artifactId&gt;
						spring-cloud-starter-archaius
					&lt;/artifactId&gt;
				&lt;/exclusion&gt;
				&lt;exclusion&gt;
				    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
                      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
				&lt;/exclusion&gt;
			&lt;/exclusions&gt;
  &lt;/dependency&gt;
</code></pre>

<p>2、同Zuul一样，把网关自身注册到Eureka Server上，目的是为了获取服务注册列表。</p>

<pre><code>server.port=8082

spring.application.name=janus-server


eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
</code></pre>

<blockquote>
<p>PS:鄙视的一点就是，Spring Cloud应该提供一个轻量级的java client，配置注册中心的地址，还不需要把网关自身注册到注册中心上。原因是：网关中间件，不需要和服务治理框架耦合的很深。</p>
</blockquote>

<h4 id="2-1-3-netty-server与spring-cloud内置的server的整合">2.1.3 Netty Server与Spring Cloud内置的Server的整合</h4>

<p>Netty Http Servert提供端口用于接收网关对外的请求，Spring Boot内置的server提供端口用于和Gateway-console交互，目前没找到Spring Boot内置Server和Netty Server合二为一的方法，但是一个服务暴露两个端口，很有必要。</p>

<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient
public class JanusServerAppliaction {

	private static Logger logger = LoggerFactory.getLogger(JanusServerAppliaction.class);

	// 非SSL的监听HTTP端口
	public static int httpPort = 8081;

	public static void main(String[] args) throws Exception {

		//①先启动Spring Boot内置Server
		SpringApplication.run(JanusServerAppliaction.class, args);

		// logger.info(&quot;services: {}&quot;, context.getBean(&quot;discoveryClient&quot;,
		// DiscoveryClient.class).getServices());

		logger.info(&quot;Gateway Server Application Start...&quot;);
		// 解析启动参数
		parseArgs(args);

		// 初始化网关Filter和配置
		logger.info(&quot;init Gateway Server ...&quot;);
		JanusBootStrap.initGateway();

		logger.info(&quot;start netty  Server...&quot;);
		final JanusNettyServer gatewayServer = new JanusNettyServer();
		// ②启动HTTP容器
		gatewayServer.startServer(httpPort);

	}
}
</code></pre>

<blockquote>
<p>NettyServer服务启动后，阻塞监听端口,会导致集成spring boot内置Server启动无日志打印，spring Boot容器也没启动。因此注意启动顺序。</p>
</blockquote>

<h3 id="2-2-提高自研网关的qps必杀技">2.2 提高自研网关的QPS必杀技</h3>

<h4 id="2-2-1-nettyserver初始化及启动代码">2.2.1 NettyServer初始化及启动代码</h4>

<p>自研网关使用netty自带的线程池，共有三组线程池，分别为bossGroup、workerGroup和executorGroup，bossGroup用于接收客户端的TCP连接，workerGroup用于处理I/O等，executorGroup用于处理网关作业(执行Filter链)。</p>

<pre><code class="language-java">public void startServer(int noSSLPort) throws InterruptedException {

		// http请求ChannelInbound
		final HttpInboundHandler httpInboundHandler = new HttpInboundHandler();

		ServerBootstrap insecure = new ServerBootstrap();
		insecure.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)
				// SO_REUSEADDR,表示允许重复使用本地地址和端口
				.option(ChannelOption.SO_REUSEADDR, Boolean.TRUE)
				.option(ChannelOption.ALLOCATOR, ByteBufManager.byteBufAllocator)
				/**
				 * SO_KEEPALIVE
				 * 该参数用于设置TCP连接，当设置该选项以后，连接会测试链接的状态，这个选项用于可能长时间没有数据交流的连接。当设置该选项以后，
				 * 如果在两小时内没有数据的通信时，TCP会自动发送一个活动探测数据报文。
				 */
				.childOption(ChannelOption.SO_KEEPALIVE, Boolean.TRUE)
				.childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)
				.childOption(ChannelOption.ALLOCATOR, ByteBufManager.byteBufAllocator)
				.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
					@Override
					public void initChannel(SocketChannel ch) throws Exception {
						ChannelPipeline pipeline = ch.pipeline();
						// 对channel监控的支持 暂不支持
						// keepalive_timeout 的支持
						pipeline.addLast(
								new IdleStateHandler(ProperityConfig.keepAliveTimeout, 0,
										0, TimeUnit.MILLISECONDS));
						// pipeline.addLast(new JanusHermesHandler());
						pipeline.addLast(new HttpResponseEncoder());
						// 经过HttpRequestDecoder会得到N个对象HttpRequest,first HttpChunk,second
						// HttpChunk,....HttpChunkTrailer
						pipeline.addLast(new HttpRequestDecoder(
								ProperityConfig.maxInitialLineLength,
								ProperityConfig.maxHeaderSize, 8192,
								ProperityConfig.validateHeaders));
						// 把HttpRequestDecoder得到的N个对象合并为一个完整的http请求对象
						pipeline.addLast(new HttpObjectAggregator(
								ProperityConfig.httpAggregatorMaxLength));

						// gzip的支持
						if (ProperityConfig.gzip) {
							pipeline.addLast(new JanusHttpContentCompressor(
									ProperityConfig.gzipLevel,
									ProperityConfig.gzipMinLength));
						}

						pipeline.addLast(httpInboundHandler);
					}
				});

		ChannelFuture insecureFuture = insecure.bind(noSSLPort).sync();

		logger.info(&quot;[listen HTTP NoSSL][&quot; + noSSLPort + &quot;]&quot;);

		/**
		 * Wait until the server socket is closed.&lt;/br&gt;
		 * 找到之前的无日志打印spring 容器也没启动的原因了，集成spring boot
		 * 和eureka放上放下并不是问题，是因为JanusNettyServer服务启动后，阻塞监听端口导致的
		 **/
		insecureFuture.channel().closeFuture().sync();
		logger.info(&quot;[stop HTTP NoSSL success]&quot;);

 }

</code></pre>

<h4 id="2-2-2-基于netty-channel-pool实现rest的异步转发">2.2.2 基于Netty Channel Pool实现REST的异步转发</h4>

<p>RestInvokerFilter异步转发Filter，基于Netty Channel Pool实现REST的异步转发,提高自网关的性能的必杀技。</p>

<pre><code class="language-java">public class RestInvokerFilter extends AbstractFilter {

	
	@Override
	public void run(final AbstractFilterContext filterContext,
			final JanusHandleContext janusHandleContext) throws Exception {
        
        // 自定义LB从Spring Cloud中服务注册缓存列表中获取服务实例
		ServiceInstance serviceInstance = SpringCloudHelper.getServiceInstanceByLB(
				janusHandleContext, janusHandleContext.getAPIInfo().getRouteServiceId());
		// 生成发送的Request对象
		FullHttpRequest outBoundRequest = getOutBoundHttpRequest(janusHandleContext);

		// 转发的时候设置LB获取到的主机IP和端口即可
		AsyncHttpRequest.builder()
				.remoteAddress(
						serviceInstance.getHost() + &quot;:&quot; + serviceInstance.getPort())
				.sessionContext(janusHandleContext)
				/**
				 * connection holding 500ms
				 */
				.holdingTimeout(ProperityConfig.janusHttpPoolOauthMaxHolding).build()
				.execute(new SimpleHttpCallback(janusHandleContext) {
					@Override
					public void onSuccess(FullHttpResponse result) {
						// testResult(result);
						janusHandleContext.setRestFullHttpResponse(result);
						// 跳转到下一个Filter
						filterContext.skipNextFilter(janusHandleContext);
					}

					@Override
					public void onError(Throwable e) {
						//省略
					}

					@Override
					public void onTimeout() {
						//省略
					}
				}, outBoundRequest);

	}
    
    //其余省略
}

</code></pre>

<h2 id="三-自研网关filter链的设计">三.自研网关Filter链的设计</h2>

<p>一层接口，一层 abstract类，
一层基于Event观察者模式的抽象类，一个基于观察者模式的接口，
 自定义Filter根据需要继承处理，在这里不做过多介绍。</p>

<h2 id="四-自研网关纳管spring-cloud的结果">四.自研网关纳管Spring Cloud的结果</h2>

<h3 id="4-1-自研网关注册到eureka-server上">4.1 自研网关注册到Eureka Server上</h3>

<p>把自研网关注册到Eureka Server上，用于获取服务列表，如下图所示。
<img src="/images/mw/gw/janus-01.png"></p>

<blockquote>
<p>上图中有两个服务提供者1，2，以及一个网关Server。</p>
</blockquote>

<h3 id="4-2-无缝支持rest转rest的get和post的转发">4.2 无缝支持REST转REST的GET和POST的转发</h3>

<p>自定义LB，基于Netty Channel Pool实现了GET，POST的协议适配和异步转发，如下所示。</p>

<p><img src="/images/mw/gw/janus-02.png" ></p>

<blockquote>
<p><a href="http://localhost:8081/，是本地网关Server的主机和端口。">http://localhost:8081/，是本地网关Server的主机和端口。</a></p>
</blockquote>

<h2 id="五-参考文章">五.参考文章</h2>

<p><a href="http://www.infoq.com/cn/articles/netty-threading-model/">Netty系列之Netty线程模型</a></p>

          </div>
        </div>
      </article>
    </div>
  </div>
        </div>
      </div>
    </div>
    <div class="mask hidden"></div>
  

  <script src="https://gw.alipayobjects.com/as/g/lark/site-toc/2.0.9/toc.js"></script>
<script>
  $('#page-toc').generateToc({
    contentContainer: $('.typo'),
    hasFirstLevelHeader: false,
    offsetTop: 0,
    affix: {
      bgColor: "transparent",
    },
  })
</script>



    </div>
    <div class="ant-row footer" style="background-image: linear-gradient(180deg,#050b22 0,#050b22 50%,#032158);">
  <div class="footer-content">
    <div class="ant-row footer-desc">
      <div class="ant-col-8 ant-col-offset-2 footer-team">
        <h4>我们的团队</h4>
        <p>中国，上海</p>
      </div>
      <div class="ant-col-4 ant-col-offset-2 footer-friend">
        <h4>友情链接</h4>
        <p>
          <a href="http://xujin.org">许进沉思录</a>
        </p>
        <p>
          <a href="https://springcloud.cn">Spring Cloud中国社区</a>
        </p>

      </div>
      <div class="ant-col-6 ant-col-offset-2 footer-contact">
        <h4>联系我们</h4>
        <p>业务咨询：<a href="mailto: Software_King@qq.com">Software_King@qq.com</a></p>
        <p>技术咨询：<a href="mailto: Software_King@qq.com">Software_King@qq.com</a></p>
        
      </div>
    </div>
    <div class="copyright">
      Venus Plus版权所有 &copy; 2017-2020 Venus中间件团队体系  Powered by xujin.org
    </div>
  </div>
</div>


    
    <div style="display: none">
    <script src="https://s19.cnzz.com/z_stat.php?id=1268345961&web_id=1268345961" language="JavaScript"></script>

    <script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'xujins/venus'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

    </div>
    
  </body>
</html>


